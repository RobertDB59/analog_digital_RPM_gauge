/*  tftTachR11
 * An analogue meter on a 1.8" ST7735 TFT 128 x 160 color screen
 * 
 * The meter graphic function works best with slowly changing values without
 * large rapid changes.
 * 
 * 
 * Connections Arduino Nano - ST7735
 * Ard    ST7735
 *  5V       Vcc
 * Gnd       Gnd
 * D10       CS1    // chip select tft 1
 *  D7     Reset    // not used instead connected to the reset pin of the arduino
 *  D8        A0
 * D11       SDA
 * D13       SCK
 * 3V3       LED
 * 
 * Sketch uses    26604 bytes = 86% of program memory
 * Global variables 486 bytes = 23% of dynamic memory
 * 
 * RdB, january 2019
 * 
*/

#include <SPI.h>
#include <Adafruit_GFX.h>                             // core graphics library
#include <Adafruit_ST7735.h>                          // hardware-specific library
#include <Fonts/FreeSansBold9pt7b.h>                  // font library chars 32 - 57 10pt
#include <Fonts/dSeg7Modern_Bold14.h>                 // font library chars 32 - 57 14pt

#define cs1 10                                        // if cs and dc pin allocations are changed then 
#define cs2  9                                        // if cs and dc pin allocations are changed then 
#define dc   8                                        // comment out #define F_AS_T line in "Adafruit_ILI9341_FAST.h"
#define rst  7                                        // alternatively connected to the Arduino reset pin

Adafruit_ST7735 tft1 = Adafruit_ST7735(cs1, dc, rst); // Invoke custom library
//Adafruit_ST7735 tft2 = Adafruit_ST7735(cs2, dc, rst); // Invoke custom library when using two displays


const unsigned char renaultIcon [] PROGMEM = {        // w =  14 h = 16
  0x0F,0xC0, // ....######......
  0x08,0xC0, // ....#...##......
  0x10,0xE0, // ...#....###.....
  0x11,0x90, // ...#...##..#....
  0x23,0x10, // ..#...##...#....
  0x23,0x08, // ..#...##....#...
  0x44,0x88, // .#...#..#...#...
  0x84,0x84, // #....#..#....#..
  0xF8,0x7C, // #####....#####..
  0xFC,0xFC, // ######..######..
  0x64,0x88, // .##..#..#...#...
  0x63,0x98, // .##...###..##...
  0x23,0x10, // ..#...##...#....
  0x23,0x30, // ..#...##..##....
  0x16,0x20, // ...#.##...#.....
  0x0C,0x40, // ....##...#......
  0x0F,0xC0, // ....######......
};

const unsigned char renaultLogo [] PROGMEM ={         // w = 100 h = 80
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf9, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf9, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe7, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe7, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc7, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x8f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x8f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x27, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x67, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x93, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf9, 0x1b, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x1f, 0xf9, 0x09, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xf2, 0x04, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xf2, 0x04, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xe4, 0x02, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x02, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xff, 0xc8, 0x01, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0x90, 0x00, 0x9f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xff, 0x90, 0x00, 0x9f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x07, 0xff, 0xe0, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x0c, 0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x40, 0x06, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x02, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x01, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xff, 0xf0, 0xff, 0xfb, 0xf8, 0xfc, 0xff, 0x0f, 0xfb, 0xef, 0xf1, 0xff, 0xf0, 
  0xff, 0xf8, 0xff, 0xfb, 0xf8, 0xfc, 0xff, 0x0f, 0xf3, 0xef, 0xf1, 0xff, 0xf0, 
  0x3c, 0x7c, 0x3e, 0x18, 0xfc, 0x30, 0x3f, 0x83, 0xe0, 0xc3, 0xe1, 0x9f, 0x30, 
  0x3c, 0x7c, 0x3e, 0x18, 0xfc, 0x30, 0x3f, 0x83, 0xe0, 0xc3, 0xe1, 0x9f, 0x30, 
  0x3c, 0x7c, 0x3e, 0x18, 0xfe, 0x30, 0x27, 0x83, 0xe0, 0xc3, 0xe1, 0x9f, 0x30, 
  0x3c, 0x7c, 0x3e, 0x00, 0xfe, 0x30, 0x67, 0xc3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3c, 0x78, 0x3e, 0x60, 0xdf, 0x30, 0x67, 0xc3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3f, 0xf0, 0x3f, 0xe0, 0xcf, 0x30, 0x63, 0xc3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3f, 0xe0, 0x3f, 0xe0, 0xcf, 0xb0, 0x63, 0xc3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3d, 0xf0, 0x3e, 0x60, 0xc7, 0xb0, 0xff, 0xe3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3c, 0xf0, 0x3e, 0x00, 0xc7, 0xf0, 0xc1, 0xe3, 0xe0, 0xc3, 0xe0, 0x1f, 0x00, 
  0x3c, 0xf8, 0x3e, 0x18, 0xc3, 0xf0, 0xc1, 0xe3, 0xe0, 0xc3, 0xe3, 0x9f, 0x00, 
  0x3c, 0x78, 0x3e, 0x18, 0xc3, 0xf1, 0x81, 0xf3, 0xe0, 0xc3, 0xe3, 0x9f, 0x00, 
  0x3c, 0x7c, 0x3e, 0x18, 0xc1, 0xf1, 0x81, 0xf3, 0xe0, 0xc3, 0xe3, 0x9f, 0x00, 
  0x3c, 0x7c, 0x3e, 0x18, 0xc1, 0xf3, 0x81, 0xf9, 0xf3, 0x83, 0xe7, 0x9f, 0x00, 
  0xff, 0x3e, 0xff, 0xf9, 0xf0, 0xf7, 0xc1, 0xfc, 0xff, 0x0f, 0xff, 0xbf, 0x80, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 
};

const unsigned char signature [] PROGMEM = {          // w =  58 h = 16
  0x00,0x00,0x00,0x00,0x0F,0xE0,0x00,0x00, // ....................................#######.....................
  0x00,0x00,0x00,0x07,0xFF,0xFF,0xC0,0x00, // .............................#####################..............
  0x00,0x00,0x00,0xFF,0xFF,0xFF,0xF8,0x00, // ........................#############################...........
  0x00,0x00,0x0F,0xFF,0xE0,0x0F,0xFE,0x00, // ....................###############.........###########.........
  0x00,0x00,0x7F,0xF8,0x00,0x00,0x3F,0x00, // .................############.....................######........
  0x00,0x03,0xFF,0x80,0x00,0x00,0x0F,0x00, // ..............###########...........................####........
  0x00,0x1F,0xF8,0x00,0x1E,0x00,0x07,0x00, // ...........##########..............####..............###........
  0x00,0x7F,0xC0,0x00,0x3F,0x80,0x7F,0x00, // .........#########................#######........#######........
  0x03,0xFE,0x00,0x00,0x7F,0xC7,0xFE,0x00, // ......#########..................#########...##########.........
  0x0F,0xE0,0x00,0x00,0x01,0xFF,0xF8,0x00, // ....#######............................##############...........
  0x3F,0x80,0x00,0x00,0x00,0x78,0x00,0x00, // ..#######................................####...................
  0x7C,0x00,0x00,0x00,0x00,0x3E,0x00,0x00, // .#####....................................#####.................
  0xE0,0x00,0x00,0x00,0x00,0x1F,0xC7,0xC0, // ###........................................#######...#####......
  0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xC0, // .............................................#############......
  0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0x00, // ..............................................##########........
  0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00, // ..................................................###...........
};


// color definitions
#define BLACK       0x0000                  //   0,   0,   0
#define DIMRED      0x4000                  //  64,   0,   0
#define RED         0xF800                  // 255,   0,   0
#define ORANGE      0xFC00                  // 255, 128,   0
#define YELLOW      0xFFE0                  // 255, 255,   0
#define DIMGREEN    0x0200                  //   0,  64,   0
#define GREEN       0x0600                  //   0, 192,   0
#define CYAN        0x07FF                  //   0, 255, 255
#define DARKBLUE    0x0008                  //   0,   0,  64
#define BLUE        0x0010                  //   0,   0, 128
#define DARKGREY    0x528A                  //  40,  40,  40
#define LIGHTGREY   0xE71C                  // 224, 224, 224
#define WHITE       0xFFFF                  // 255, 255, 255
#define MAGENTA     0x8010                  // 128,   0, 128

#define DEG2RAD 0.0174532925                // for testing purposes

bool engineRun     = false;                 // set flag

float conversionFactor = 0.0;               // conversion factor to get from an analogue read to a voltage
float ltx = 0;                              // Saved x coord of bottom of needle

int xca1       =    80;                     // x position center arc
int yca1       =    90;                     // y position center arc
int radx1      =    66;                     // x-axes radius
int rady1      =    66;                     // y-axes radius
int degRot     =   -90;                     // rotate meter left ot right
int startScale =   -80;
int endScale   =    81;
int old_analog =  -999;                     // Value last displayed
int old_digital = -999;                     // Value last displayed
int xDig1       =   60;
int yDig1       =  112;

uint16_t osx = 80, osy = 63;                // Saved x & y coords

uint32_t runTime = -99999;                  // time for next update


void setup() {
//  Serial.begin(115200);
  tft1.initR( INITR_BLACKTAB);
  tft1.setRotation( 1);
  tft1.fillScreen( BLACK);
  tft1.drawBitmap( 30, 24, renaultLogo , 100, 80, LIGHTGREY);
//  delay(3000);

  tft1.fillScreen( BLACK);
  tft1.setTextColor( ORANGE);     // set text color
//  tft1.drawBitmap( 54, 105, signature, 58, 16, BLUE);

  // calculation of the conversion factor
//  conversionFactor = voltArd / (r2VoltDiv / (r1VoltDiv + r2VoltDiv)) / 1023;

  showBackground();

  runTime = millis(); // Next update time
}


void loop() {
  if (millis() - runTime >= 2000) { // Execute every 0.2s
    runTime = millis();

    int reading = 0;
    reading = random( 0, 801);      // Test with random value

    showDigital(reading);           // Update digital reading

    plotNeedle(reading, 8);         // Update analogue meter, 8ms delay per needle increment

  }
}


//**************************************************************************
//  tft1 - draw the fixed portions of the layout on the screen
//**************************************************************************
void showBackground() {

  tft1.fillRoundRect ( 0        , 66        , 160,  60, 30, DARKGREY);
  tft1.fillRect      ( 0        , 66        , 160,  19, BLACK);       // hide upper part rounded rectangle
  tft1.fillRect      ( xDig1    , yDig1 - 23,  66,  32, BLACK);       // draw background for 7 segment digits
  tft1.drawRect      ( xDig1 - 1, yDig1 - 24,  68,  34, LIGHTGREY);   // draw bezel line 7 segment
  tft1.drawRoundRect ( 0        , 0         , 160, 128, 30, WHITE);   // draw rounded rectangle 
  tft1.drawRoundRect ( 1        , 1         , 158, 126, 25, WHITE);   // draw rounded rectangle 

  tft1.drawBitmap( 133, 102, renaultIcon, 14, 17, BLACK);

  for (int i = startScale; i < endScale; i += 2) {         // draw scale marks
    int tl = 9;                               // long scale mark length

    // Coodinates of mark to draw
    float sx = cos((i + degRot) * DEG2RAD);
    float sy = sin((i + degRot) * DEG2RAD);
    uint16_t x0 = sx * (radx1 + tl) + xca1;
    uint16_t y0 = sy * (rady1 + tl) + yca1;
    uint16_t x1 = sx * (radx1) + xca1;
    uint16_t y1 = sy * (rady1) + yca1;

    // Coordinates of next mark for zone fill
    float sx2 = cos((i + 4 + degRot) * DEG2RAD);
    float sy2 = sin((i + 4 + degRot) * DEG2RAD);
    int x2 = sx2 * (radx1 + tl) + xca1;
    int y2 = sy2 * (rady1 + tl) + yca1;
    int x3 = sx2 * radx1 + xca1;
    int y3 = sy2 * rady1 + yca1;

    // GREEN zone limits RPM < 5000
    if (i >= -120 && i < 20) {
      tft1.fillTriangle ( x0, y0, x1, y1, x2, y2, DIMGREEN);
      tft1.fillTriangle ( x1, y1, x2, y2, x3, y3, DIMGREEN);
    }

    // RED zone limits RPM >= 5000 TOO HIGH
    if (i >= 20 && i < 78) {
      tft1.fillTriangle(x0, y0, x1, y1, x2, y2, RED);
      tft1.fillTriangle(x1, y1, x2, y2, x3, y3, RED);
    }

    // scale tick length
    if (i % 20 != 0) tl = 7;  // modulo 20
    if (i % 10 != 0) tl = 4;  // modulo 10

    // recalculate coords incase tick lenght changed
    x0 = sx * (radx1 + tl) + xca1;
    y0 = sy * (rady1 + tl) + yca1;
    x1 = sx * radx1 + xca1;
    y1 = sy * rady1 + yca1;

    // draw tick
    tft1.drawLine(x0, y0, x1, y1, WHITE);

    if (i % 20 == 0) {                        // put labels for scale
      x0 = sx * (radx1 + tl + 14) + xca1;     // calculate label positions
      y0 = sy * (rady1 + tl + 14) + yca1;
      tft1.setTextColor( ORANGE);
      switch (i / 20) {
//        case -4: tft1.setCursor( x0 +  6, y0 + 4); tft1.print( " 0"); break;  // position tweak
        case -3: tft1.setCursor( x0     , y0 + 2); tft1.print( "10"); break;  // position tweak
        case -2: tft1.setCursor( x0     , y0 + 1); tft1.print( "20"); break;  // position tweak
        case -1: tft1.setCursor( x0 -  2, y0 + 3); tft1.print( "30"); break;  // position tweak
        case  0: tft1.setCursor( x0 -  4, y0 + 4); tft1.print( "40"); break;  // position tweak
        case  1: tft1.setCursor( x0 -  8, y0 + 3); tft1.print( "50"); break;  // position tweak
        case  2: tft1.setCursor( x0 -  9, y0 + 1); tft1.print( "60"); break;  // position tweak
        case  3: tft1.setCursor( x0 - 10, y0 + 2); tft1.print( "70"); break;  // position tweak
//        case  4: tft1.setCursor( x0 - 24, y0 + 8); tft1.print( "80"); break;  // position tweak
      }
    }

    // now draw the arc of the scale
    sx = cos((i + 5 + degRot) * DEG2RAD);
    sy = sin((i + 5 + degRot) * DEG2RAD);
    x0 = sx * radx1 + xca1;
    y0 = sy * rady1 + yca1;

    // draw scale arc, don't draw the last part
    if (i < endScale - 4) tft1.drawLine ( x0, y0, x1, y1, WHITE); // draw bottom arc of scale
  }

    int rpmx1 =  12;
    int rpmy1 = 116;
    tft1.setFont( &FreeSansBold9pt7b);
    tft1.setTextColor( BLACK);
    tft1.setCursor ( rpmx1    , rpmy1);
    tft1.print("RPM");
    tft1.setCursor ( rpmx1 + 4, rpmy1);
    tft1.print("RPM");
    tft1.setCursor ( rpmx1    , rpmy1 + 4);
    tft1.print("RPM");
    tft1.setCursor ( rpmx1 + 4, rpmy1 + 4);
    tft1.print("RPM");
    tft1.setTextColor( LIGHTGREY);
    tft1.setCursor ( rpmx1 + 2, rpmy1 + 2);
    tft1.print("RPM");
    tft1.setFont();
    tft1.setTextColor( YELLOW);
    tft1.setCursor ( rpmx1 - 4, rpmy1 - 25);
    tft1.print( "Bougnard");
    tft1.setTextColor( LIGHTGREY);
    tft1.setCursor ( 130, 90);
    tft1.print( "x10");

  plotNeedle( 0, 0); // Put meter needle at 0
}


// #########################################################################
// Update needle position
// This function is blocking while needle moves, time depends on ms_delay
// 10ms minimises needle flicker if text is drawn within needle sweep area
// Smaller values OK if text not in sweep area, zero for instant movement but
// does not look realistic... (note: 100 increments for full scale deflection)
// #########################################################################
void plotNeedle(int value, byte ms_delay) {
/*
  tft1.setTextColor( WHITE);
  tft1.setCursor ( xDig1 - 10, yDig1);
  tft1.setFont( &dseg7modern_bold14pt7b);
  char buf[8];
  dtostrf(value, 3, 0, buf);
  tft1.print(buf);
  tft1.setFont();
*/
  value = value / 10;
  if (value < 0) value = 0; // Limit value to emulate needle end stops
  if (value > 80) value = 80;

  // Move the needle util new value reached
  while (!(value == old_analog)) {
    if (old_analog < value) old_analog++;
    else old_analog--;

    if (ms_delay == 0) old_analog = value; // Update immediately id delay is 0

    float sdeg = map(old_analog, 0, 80, -170, -10); // Map value to angle 
    // Calcualte tip of needle coords
    float sx = cos( sdeg * DEG2RAD);
    float sy = sin( sdeg * DEG2RAD);

    // Calculate x delta of needle start (does not start at pivot point)
    float tx = tan((sdeg + 90) * DEG2RAD);

    // Erase old needle image
    tft1.drawLine( xca1 + 6 * ltx - 2, yca1 - 6, osx - 1, osy, BLACK);
    tft1.drawLine( xca1 + 6 * ltx - 1, yca1 - 6, osx - 1, osy, BLACK);
    tft1.drawLine( xca1 + 6 * ltx    , yca1 - 6, osx    , osy, BLACK);
    tft1.drawLine( xca1 + 6 * ltx + 1, yca1 - 6, osx + 1, osy, BLACK);
    tft1.drawLine( xca1 + 6 * ltx + 2, yca1 - 6, osx + 1, osy, BLACK);

    // Re-plot text under needle
    tft1.setTextColor( LIGHTGREY);
    tft1.setCursor ( 65, 40);
    tft1.print( "x 100");

    ltx = tx;                         // store new needle end coords for next erase
    osx = sx * 63 + xca1;             // needle coords and needle length
    osy = sy * 63 + yca1;             // needle coords and needle length

    // Draw the needle in the new postion, magenta makes needle a bit bolder
    // draws 3 lines to thicken needle
    tft1.drawLine( xca1 + 6 * ltx - 2, yca1 - 6, osx - 1, osy, RED);
    tft1.drawLine( xca1 + 6 * ltx - 1, yca1 - 6, osx - 1, osy, ORANGE);
    tft1.drawLine( xca1 + 6 * ltx    , yca1 - 6, osx    , osy, ORANGE);
    tft1.drawLine( xca1 + 6 * ltx + 1, yca1 - 6, osx + 1, osy, ORANGE);
    tft1.drawLine( xca1 + 6 * ltx + 2, yca1 - 6, osx + 1, osy, RED);

    // Slow needle down slightly as it approaches new postion
    if (abs(old_analog - value) < 10) ms_delay += ms_delay / 5;

    // Wait before next update
    delay(ms_delay);
  }
}


// #########################################################################
//  update digital meter reading
// #########################################################################
void showDigital(int value)
{
  if (value == old_digital) return;       // return if no change to prevent flicker
  if (value < 0) value = 0;               // Constrain lower limit to 0
  if (value > 999) value = 999;           // Constrain upper limit to 999

  tft1.setTextColor( DIMRED);             // Plot over numbers in dim red
  tft1.setCursor ( xDig1, yDig1);
  tft1.setFont( &dseg7modern_bold14pt7b);
  tft1.print("888"); //Erase old value

  // Nb. 32 pixels wide +2 gap per digit

  // Update with new value
  tft1.setTextColor( ORANGE); // Dont draw background to leave dim segments
  if (value < 10){
    tft1.setCursor ( xDig1 + 44, yDig1 + 6);
    tft1.print(value);
  }
  else if (value < 100){
    tft1.setCursor ( xDig1 + 22, yDig1 + 6);
    tft1.print(value);
  }
  else {
    tft1.setCursor ( xDig1     , yDig1 + 6);
    tft1.print(value);
  }
  old_digital = value;
  tft1.setFont ();
}
